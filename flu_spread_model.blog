type County;
type Region;
type Week;

distinct County counties[82];
distinct Region regions[9];
distinct Week weeks[51];

// ----
// define hyperparameters
// ----
random Real rho ~ Gamma(1.05, 0.5);
random Real tau1 ~ Gamma(3.0, 0.1);
random Real tau2 ~ Gamma(10.0, 0.1);
random Real beta1 ~ Gaussian(0.0, 10.0);
random Real beta2 ~ Gaussian(0.0, 10.0);

// ----
// load data
// ----
fixed RealMatrix county_pop = loadRealMatrix("data_processed/county_pops.txt");
fixed RealMatrix region_pop = loadRealMatrix("data_processed/region_pops.txt");
fixed RealMatrix county_map = loadRealMatrix("data_processed/county_map.txt");

fixed RealMatrix covariates1 = loadRealMatrix("data_processed/covariates1.txt");
fixed RealMatrix covariates2 = loadRealMatrix("data_processed/covariates2.txt");

fixed RealMatrix D = loadRealMatrix("data_processed/D.txt");
fixed RealMatrix W = loadRealMatrix("data_processed/W.txt");

// ---
// correlation has a prior distributed Gaussian with mean zero,
// variance defined by the diagonal matrix, treated here as a vector
// ---
random Real correlation(County c, Week t) ~
  Gaussian(0.0, D[toInt(c)]);

random Boolean spatial_edge(County c1, Week t1, County c2, Week t2) ~
  BooleanDistrib(tau1 * exp(rho * correlation(c1, t1) * correlation(c2, t2)));

random Boolean temporal_edge(County c1, Week t1, County c2, Week t2) ~
  BooleanDistrib(tau1 * exp(correlation(c1, t1) * correlation(c2, t2)));

// ----
// county rate calculated by logit model.
// ----
random Real noise(County c, Week t) ~
  Gaussian(0.0, 1.0 / tau2);

random Real logit(County c, Week t) ~
  toReal(beta1 * covariates1[toInt(c)][toInt(t)] +
         beta2 * covariates2[toInt(c)][toInt(t)] +
         correlation(c, t)) +
         noise(c, t);

random Real county_rate(County c, Week t) ~
  exp(logit(c, t)) / (1.0 + exp(logit(c, t)));

// ----
// region rate is the sum over county rates
//   (make nondeterministic as Gaussian with very small variance)
// ----
random Real region_rate(Region r, Week t) ~
  Gaussian(
    sum({
      (county_rate(c, t) * county_pop[toInt(c)])
      for County c : county_map[toInt(r)][toInt(c)] == 1.0
    }) / region_pop[toInt(r)],
  0.001);

obs spatial_edge(c1, t1, c2, t2) = true for County c1, Week t1, County c2, Week t2 : toInt(t1) + 1 == toInt(t2);
obs temporal_edge(c1, t1, c2, t2) = true for County c1, Week t1, County c2, Week t2 : W[toInt(c1)][toInt(c2)] == 1.0;

